pragma solidity >=0.6.7;

import "./Address.sol";
import "./EternalStorage.sol";
import "./ISettings.sol";
import "./IACL.sol";
import "./IAccessControl.sol";
import "./IACLConstants.sol";

/**
 * @dev Base contract for interacting with the ACL.
 */
contract AccessControl is EternalStorage, IAccessControl, IACLConstants {
  using Address for address;

  // BEGIN: Generated by script outputConstants.js
  // DO NOT MANUALLY MODIFY THESE VALUES!
  bytes32 constant public ROLE_CAPITAL_PROVIDER = 0x428fa9969c6b3fab7bbdac20b73706f1f670a386be0a76d4060c185898b2aa22;
  bytes32 constant public ROLE_BROKER = 0x2623111b4a77e415ab5147aeb27da976c7a27950b6ec4022b4b9e77176266992;
  bytes32 constant public ROLE_INSURED_PARTY = 0x737de6bdef2e959d9f968f058e3e78b7365d4eda8e4023ecac2d51e3dbfb1401;
  bytes32 constant public ROLE_CLAIMS_ADMIN = 0x391db9b692991836c38aedfd24d7f4c9837739d4ee0664fe4ee6892a51e025a7;
  bytes32 constant public ROLE_ENTITY_ADMIN = 0x0922a3d5a8713fcf92ec8607b882fd2fcfefd8552a3c38c726d96fcde8b1d053;
  bytes32 constant public ROLE_ENTITY_MANAGER = 0xcfd13d23f7313d54f3a6d98c505045c58749561dd04531f9f2422a8818f0c5f8;
  bytes32 constant public ROLE_ENTITY_REP = 0xcca1ad0e9fb374bbb9dc3d0cbfd073ef01bd1d01d5a35bd0a93403fbee64318d;
  bytes32 constant public ROLE_POLICY_OWNER = 0x7f7cc8b2bac31c0e372310212be653d159f17ff3c41938a81446553db842afb6;
  bytes32 constant public ROLE_SYSTEM_ADMIN = 0xd708193a9c8f5fbde4d1c80a1e6f79b5f38a27f85ca86eccac69e5a899120ead;
  bytes32 constant public ROLE_SYSTEM_MANAGER = 0x807c518efb8285611b15c88a7701e4f40a0e9a38ce3e59946e587a8932410af8;
  bytes32 constant public ROLE_UNDERWRITER = 0x8858a0dfcbfa158449ee0a3b5dae898cecc0746569152b05bbab9526bcc16864;
  bytes32 constant public ROLEGROUP_CAPITAL_PROVIDERS = 0x2db57b52c5f263c359ba92194f5590b4a7f5fc1f1ca02f10cea531182851fe28;
  bytes32 constant public ROLEGROUP_BROKERS = 0x8d632412946eb879ebe5af90230c7db3f6d17c94c0ecea207c97e15fa9bb77c5;
  bytes32 constant public ROLEGROUP_INSURED_PARTYS = 0x65d0db34d07de31cfb8ca9f95dabc0463ce6084a447abb757f682f36ae3682e3;
  bytes32 constant public ROLEGROUP_CLAIMS_ADMINS = 0x5c7c2bcb0d2dfef15c423063aae2051d462fcd269b5e9b8c1733b3211e17bc8a;
  bytes32 constant public ROLEGROUP_ENTITY_ADMINS = 0x251766d8c7c7a6b927647b0f20c99f490db1c283eb0c482446085aaaa44b5e73;
  bytes32 constant public ROLEGROUP_ENTITY_MANAGERS = 0xa33a59233069411012cc12aa76a8a426fe6bd113968b520118fdc9cb6f49ae30;
  bytes32 constant public ROLEGROUP_ENTITY_REPS = 0x610cf17b5a943fc722922fc6750fb40254c24c6b0efd32554aa7c03b4ca98e9c;
  bytes32 constant public ROLEGROUP_POLICY_OWNERS = 0xc59d706f362a04b6cf4757dd3df6eb5babc7c26ab5dcc7c9c43b142f25da10a5;
  bytes32 constant public ROLEGROUP_SYSTEM_ADMINS = 0xab789755f97e00f29522efbee9df811265010c87cf80f8fd7d5fc5cb8a847956;
  bytes32 constant public ROLEGROUP_SYSTEM_MANAGERS = 0x7c23ac65f971ee875d4a6408607fabcb777f38cf73b3d6d891648646cee81f05;
  bytes32 constant public ROLEGROUP_TRADERS = 0x9f4d1dc1107c7d9d9f533f41b5aa5dbbb3b830e3b597338a8aee228ab083eb3a;
  bytes32 constant public ROLEGROUP_UNDERWRITERS = 0x18ecf8d2173ca8a5766fd7dde3bdb54017dc5413dc07cd6ba1785b63e9c62b82;
  // END: Generated by script outputConstants.js

  /**
   * @dev Constructor.
   * @param _settings Address of Settings.
   */
  constructor (address _settings) public {
    dataAddress["settings"] = _settings;
    dataBytes32["aclContext"] = acl().generateContextFromAddress(address(this));
  }

  /**
   * @dev Check that sender is an admin.
   */
  modifier assertIsAdmin () {
    require(isAdmin(msg.sender), 'must be admin');
    _;
  }

  /**
   * @dev Check if given address has admin privileges.
   * @param _addr Address to check.
   * @return true if so
   */
  function isAdmin (address _addr) public view override returns (bool) {
    return acl().isAdmin(_addr);
  }

  /**
   * @dev Check if given address has a role in the given role group in the current context.
   * @param _addr Address to check.
   * @param _roleGroup Rolegroup to check against.
   * @return true if so
   */
  function inRoleGroup (address _addr, bytes32 _roleGroup) public view override returns (bool) {
    return inRoleGroupWithContext(aclContext(), _addr, _roleGroup);
  }

  /**
   * @dev Check if given address has given role in the current context.
   * @param _addr Address to check.
   * @param _role Role to check against.
   * @return true if so
   */
  function hasRole (address _addr, bytes32 _role) public view override returns (bool) {
    return hasRoleWithContext(aclContext(), _addr, _role);
  }

  /**
   * @dev Check if given address has a role in the given rolegroup in the given context.
   * @param _ctx Context to check against.
   * @param _addr Address to check.
   * @param _roleGroup Role group to check against.
   * @return true if so
   */
  function inRoleGroupWithContext (bytes32 _ctx, address _addr, bytes32 _roleGroup) public view override returns (bool) {
    return acl().hasRoleInGroup(_ctx, _addr, _roleGroup);
  }

  /**
   * @dev Check if given address has given role in the given context.
   * @param _ctx Context to check against.
   * @param _addr Address to check.
   * @param _role Role to check against.
   * @return true if so
   */
  function hasRoleWithContext (bytes32 _ctx, address _addr, bytes32 _role) public view override returns (bool) {
    return acl().hasRole(_ctx, _addr, _role) != DOES_NOT_HAVE_ROLE;
  }

  /**
   * @dev Get ACL reference.
   * @return ACL reference.
   */
  function acl () public view override returns (IACL) {
    return ISettings(dataAddress["settings"]).acl();
  }

  /**
   * @dev Get current ACL context.
   * @return the context.
   */
  function aclContext () public view override returns (bytes32) {
    return dataBytes32["aclContext"];
  }
}
